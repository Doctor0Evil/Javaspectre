// Path: src/capabilities/RepoBlueprinting.js
// Zero-config repository scaffolding from a single input fragment.

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class RepoBlueprinting {
  constructor(options = {}) {
    this.templateDir =
      options.templateDir || path.join(__dirname, "..", "..");
  }

  /**
   * Generate a repo blueprint on disk based on a prompt or code fragment.
   *
   * @param {object} params
   * @param {string} params.targetDir
   * @param {string} params.prompt
   * @param {string} [params.codeFragment]
   * @returns {object} blueprintResult
   */
  generateRepo(params) {
    const { targetDir, prompt, codeFragment } = params || {};
    if (!targetDir || !prompt) {
      throw new Error(
        "RepoBlueprinting.generateRepo: targetDir and prompt are required."
      );
    }

    this.#ensureDir(targetDir);

    const nameSlug = this.#slugFromPrompt(prompt);
    const pkg = this.#buildPackageJson(nameSlug, prompt);
    const readme = this.#buildReadme(nameSlug, prompt);
    const gitignore = this.#defaultGitignore();
    const indexJs = this.#bootstrapIndex(codeFragment || prompt);

    this.#writeJson(path.join(targetDir, "package.json"), pkg);
    this.#writeText(path.join(targetDir, "README.md"), readme);
    this.#writeText(path.join(targetDir, ".gitignore"), gitignore);

    const srcDir = path.join(targetDir, "src");
    this.#ensureDir(srcDir);
    this.#writeText(path.join(srcDir, "index.js"), indexJs);

    const testsDir = path.join(targetDir, "tests");
    this.#ensureDir(testsDir);
    this.#writeText(
      path.join(testsDir, "index.test.js"),
      this.#defaultTest()
    );

    const ciDir = path.join(targetDir, ".github", "workflows");
    this.#ensureDir(ciDir);
    this.#writeText(
      path.join(ciDir, "ci.yml"),
      this.#defaultCiWorkflow()
    );

    return {
      name: nameSlug,
      targetDir,
      files: [
        "package.json",
        "README.md",
        ".gitignore",
        "src/index.js",
        "tests/index.test.js",
        ".github/workflows/ci.yml"
      ]
    };
  }

  #ensureDir(dir) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }

  #slugFromPrompt(prompt) {
    return String(prompt)
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "")
      .slice(0, 40) || "javaspectre-project";
  }

  #buildPackageJson(nameSlug, prompt) {
    return {
      name: nameSlug,
      version: "0.1.0",
      description: `Generated by Javaspectre for intent: ${prompt}`,
      type: "module",
      main: "src/index.js",
      scripts: {
        test: "node tests/index.test.js",
        start: "node src/index.js"
      },
      license: "MIT"
    };
  }

  #buildReadme(nameSlug, prompt) {
    return [
      `# ${nameSlug}`,
      "",
      "Generated by Javaspectre from the following intent:",
      "",
      `> ${prompt}`,
      "",
      "## Quick start",
      "",
      "```
      "npm install",
      "npm test",
      "npm start",
      "```",
      "",
      "This repository was scaffolded to be immediately runnable and easily extensible."
    ].join("\n");
  }

  #defaultGitignore() {
    return [
      "node_modules",
      "dist",
      ".DS_Store",
      "npm-debug.log*",
      "yarn-debug.log*",
      "yarn-error.log*"
    ].join("\n");
  }

  #bootstrapIndex(seed) {
    const safeSeed = String(seed || "").replace(/`/g, "'");
    return [
      "// Auto-generated entrypoint by Javaspectre RepoBlueprinting.",
      "",
      "export function main() {",
      `  const intent = ${JSON.stringify(safeSeed)};`,
      "  const message = `Javaspectre bootstrap for: ${intent}`;",
      "  console.log(message);",
      "  return message;",
      "}",
      "",
      "if (import.meta.url === `file://${process.argv[1]}`) {",
      "  main();",
      "}"
    ].join("\n");
  }

  #defaultTest() {
    return [
      "// Minimal sanity test for Javaspectre-generated repo.",
      "",
      "import { main } from \"../src/index.js\";",
      "",
      "function assert(condition, message) {",
      "  if (!condition) {",
      "    throw new Error(message || \"Assertion failed.\");",
      "  }",
      "}",
      "",
      "const result = main();",
      "assert(typeof result === \"string\", \"main() should return a string.\");",
      "console.log(\"index.test.js OK\");"
    ].join("\n");
  }

  #defaultCiWorkflow() {
    return [
      "name: Generated Repo CI",
      "",
      "on:",
      "  push:",
      "    branches: [ main ]",
      "  pull_request:",
      "    branches: [ main ]",
      "",
      "jobs:",
      "  test:",
      "    runs-on: ubuntu-latest",
      "    steps:",
      "      - name: Checkout",
      "        uses: actions/checkout@v4",
      "      - name: Use Node.js",
      "        uses: actions/setup-node@v4",
      "        with:",
      "          node-version: '20.x'",
      "      - name: Install dependencies",
      "        run: npm install",
      "      - name: Run tests",
      "        run: npm test"
    ].join("\n");
  }

  #writeJson(filePath, obj) {
    const text = JSON.stringify(obj, null, 2);
    this.#writeText(filePath, text);
  }

  #writeText(filePath, text) {
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(filePath, text, "utf8");
  }
}

export default RepoBlueprinting;
